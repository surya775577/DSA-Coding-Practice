# Maximum Circular Subarray Sum

## ðŸ“Œ Problem Overview

Given a **circular array of integers**, the task is to find the **maximum possible sum of a non-empty subarray**.
In a circular array, subarrays may **wrap around** from the end of the array back to the beginning.

### Example

```
Input:  [8, -8, 9, -9, 10, -11, 12]
Output: 22
```

---

## ðŸ§  Core Idea

The maximum subarray sum in a circular array can be obtained in **two possible ways**:

1. **Non-wrapping subarray**
   â†’ Standard maximum subarray problem solved using **Kadaneâ€™s Algorithm**.

2. **Wrapping subarray**
   â†’ The maximum circular sum equals:

   ```
   total_array_sum âˆ’ minimum_subarray_sum
   ```

   This works because removing the minimum subarray leaves the maximum wrapping subarray.

The final answer is the **maximum of these two cases**.

---

## âš ï¸ Important Edge Case

If **all elements are negative**, the wrapping case becomes invalid.
In this scenario, the correct result is simply the **largest (least negative) element**, which Kadaneâ€™s algorithm already provides.

---

## ðŸ› ï¸ Algorithm Steps

1. Use Kadaneâ€™s Algorithm to compute:

   * Maximum subarray sum (non-circular case)
2. Use a modified Kadaneâ€™s Algorithm to compute:

   * Minimum subarray sum
3. Compute the total sum of the array
4. If all elements are negative, return the maximum subarray sum
5. Otherwise, return:

   ```
   max(max_subarray_sum, total_sum âˆ’ min_subarray_sum)
   ```

---

## ðŸ§© Implementation (Python)

```python
class Solution:
    def maxCircularSum(self, arr):
        t = 0
        max_ending = max_so_far = arr[0]
        min_ending = min_so_far = arr[0]

        for i, x in enumerate(arr):
            t += x

            if i > 0:
                max_ending = max(x, max_ending + x)
                max_so_far = max(max_so_far, max_ending)

                min_ending = min(x, min_ending + x)
                min_so_far = min(min_so_far, min_ending)

        if max_so_far < 0:
            return max_so_far

        return max(max_so_far, t - min_so_far)
```

---

## â±ï¸ Complexity Analysis

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(1)`

The algorithm performs a single pass through the array and uses constant extra space, making it efficient for large inputs (up to `10^5` elements).

---


